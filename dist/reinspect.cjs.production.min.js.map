{"version":3,"file":"reinspect.cjs.production.min.js","sources":["../src/context.ts","../src/StateInspector.tsx","../src/useReducer.ts","../src/useState.ts"],"sourcesContent":["import React, { Reducer } from \"react\"\nimport { Store } from \"redux\"\n\ntype UnsubscribeFn = () => void\n\nexport interface ReducerOptions {\n  /**\n   * When set to true, deletes the state from the reducer when the component/reducer is unmounted.\n   * Defaults to false because not desirable when using StrictMode. May want to clean-up state in\n   * production environments if a reducer has a lot of state.\n   */\n  teardownOnUnmount?: boolean\n}\n\nexport type EnhancedStore = Store & {\n  registerHookedReducer: (\n    reducer: Reducer<any, any>,\n    initialState: any,\n    reducerId: string | number,\n    options: ReducerOptions\n  ) => UnsubscribeFn\n}\n\nexport const StateInspectorContext = React.createContext<\n  EnhancedStore | undefined\n>(undefined)\n","import { EnhancerOptions } from \"@redux-devtools/extension\"\nimport React, { Reducer, ReducerAction, useEffect } from \"react\"\nimport { createStore } from \"redux\"\nimport { EnhancedStore, StateInspectorContext } from \"./context\"\n\ninterface StateInspectorProps extends EnhancerOptions {\n  initialState?: any\n}\n\ninterface StoreReducerAction {\n  type: string\n  payload: any\n}\n\n// This hack is required because creating the store is an impure effect. When it calls the\n// method on the window, it registers it with the extension. In Strict Mode, this will\n// happen **twice** during development, regardless of if you use `useMemo` or `useState` or\n// try and workaround it with a ref, showing two instances of your app in the extension.\n// Using a module-scope variable requires that this component only be used once globally,\n// otherwise it won't create the store.\nlet registered = false\nlet store: EnhancedStore | undefined\n\nconst omit = (obj: Record<string, any>, keyToRemove: string) =>\n  Object.keys(obj)\n    .filter(key => key !== keyToRemove)\n    .reduce<Record<string, any>>((acc, key) => {\n      acc[key] = obj[key]\n      return acc\n    }, {})\n\nconst createReinspectStore = ({\n  name = \"React state\",\n  initialState = {},\n  actionsDenylist,\n  ...options\n}: StateInspectorProps): EnhancedStore | undefined => {\n  if (typeof window === \"undefined\" || !window.__REDUX_DEVTOOLS_EXTENSION__) {\n    return undefined\n  }\n\n  const registeredReducers: Record<\n    string | number,\n    Reducer<any, ReducerAction<any>>\n  > = {}\n\n  const storeReducer: Reducer<any, StoreReducerAction> = (state, action) => {\n    const actionReducerId = action.type.split(\"/\")[0]\n    const isInitAction = /\\/_init$/.test(action.type)\n    const isTeardownAction = /\\/_teardown$/.test(action.type)\n\n    const currentState = isTeardownAction\n      ? omit(state, actionReducerId)\n      : { ...state }\n\n    return Object.keys(registeredReducers).reduce((acc, reducerId) => {\n      const reducer = registeredReducers[reducerId]\n      const reducerState = state[reducerId]\n      const reducerAction = action.payload\n      const isForCurrentReducer = actionReducerId === reducerId\n\n      if (isForCurrentReducer) {\n        acc[reducerId] = isInitAction\n          ? action.payload\n          : reducer(reducerState, reducerAction)\n      } else {\n        acc[reducerId] = reducerState\n      }\n\n      return acc\n    }, currentState)\n  }\n\n  const store = (createStore(\n    storeReducer,\n    initialState,\n    window.__REDUX_DEVTOOLS_EXTENSION__({\n      name,\n      actionsDenylist: [\"/_init\", \"/_teardown\"].concat(actionsDenylist ?? []),\n      ...options\n    })\n  ) as any) as EnhancedStore\n\n  store.registerHookedReducer = (reducer, initialState, reducerId, options) => {\n    registeredReducers[reducerId] = reducer\n\n    store.dispatch({\n      type: `${reducerId}/_init`,\n      payload: initialState\n    })\n\n    return () => {\n      delete registeredReducers[reducerId]\n\n      if (options.teardownOnUnmount) {\n        store.dispatch({\n          type: `${reducerId}/_teardown`\n        })\n      }\n    }\n  }\n\n  return store\n}\n\nexport const StateInspector: React.FC<React.PropsWithChildren<\n  StateInspectorProps\n>> = ({ children, ...props }) => {\n  if (!registered) {\n    store = createReinspectStore(props)\n    registered = true\n  }\n\n  useEffect(() => {\n    store?.dispatch({ type: \"REINSPECT/@@INIT\", payload: {} })\n  }, [])\n\n  return (\n    <StateInspectorContext.Provider value={store}>\n      {children}\n    </StateInspectorContext.Provider>\n  )\n}\n","/* eslint-disable react-hooks/rules-of-hooks */\nimport {\n  useReducer as useReactReducer,\n  Reducer,\n  Dispatch,\n  useState,\n  useEffect,\n  useContext,\n  ReducerState,\n  ReducerAction\n} from \"react\"\nimport { StateInspectorContext, EnhancedStore, ReducerOptions } from \"./context\"\n\nexport function useHookedReducer<S, A>(\n  reducer: Reducer<S, A>,\n  initialState: S,\n  store: EnhancedStore,\n  reducerId: string | number,\n  options: ReducerOptions = {}\n): [S, Dispatch<A>] {\n  const [initialReducerState] = useState(() => {\n    const initialStateInStore = store.getState()[reducerId]\n    return initialStateInStore === undefined\n      ? initialState\n      : initialStateInStore\n  })\n\n  const [localState, setState] = useState<S>(initialReducerState)\n\n  const [dispatch] = useState<Dispatch<A>>(() => {\n    return (action: any) => {\n      if (\n        action &&\n        typeof action === \"object\" &&\n        typeof action.type === \"string\"\n      ) {\n        store.dispatch({\n          type: `${reducerId}/${action.type}`,\n          payload: action\n        })\n      } else {\n        store.dispatch({\n          type: reducerId,\n          payload: action\n        })\n      }\n    }\n  })\n\n  const [cleanup] = useState(() => {\n    const teardown = store.registerHookedReducer(\n      reducer,\n      initialReducerState,\n      reducerId,\n      options\n    )\n    let lastReducerState = localState\n    const unsubscribe = store.subscribe(() => {\n      const storeState: any = store.getState()\n      const reducerState = storeState[reducerId]\n\n      if (lastReducerState !== reducerState) {\n        setState(reducerState)\n      }\n\n      lastReducerState = reducerState\n    })\n    return () => {\n      teardown()\n      unsubscribe()\n    }\n  })\n\n  useEffect(() => {\n    return cleanup\n  }, [cleanup])\n\n  return [localState, dispatch]\n}\n\nexport function useReducer<R extends Reducer<any, any>>(\n  reducer: R,\n  initialState: ReducerState<R>,\n  id?: string | number\n): [ReducerState<R>, Dispatch<ReducerAction<R>>]\nexport function useReducer<R extends Reducer<any, any>, I>(\n  reducer: R,\n  initialState: I,\n  initializer: (arg: I) => ReducerState<R>,\n  id?: string | number\n): [ReducerState<R>, Dispatch<ReducerAction<R>>]\nexport function useReducer<R extends Reducer<any, any>, I>(\n  reducer: R,\n  initialState: I & ReducerState<R>,\n  initializer: (arg: I & ReducerState<R>) => ReducerState<R>,\n  id?: string | number\n): [ReducerState<R>, Dispatch<ReducerAction<R>>]\nexport function useReducer<R extends Reducer<any, any>, I>(\n  reducer: R,\n  initialState: I & ReducerState<R>,\n  ...args: any[]\n) {\n  let id: string | number | undefined\n  let initializer:\n    | ((arg: I | (I & ReducerState<R>)) => ReducerState<R>)\n    | undefined\n\n  if (args.length === 2) {\n    initializer = args[0]\n    id = args[1]\n  } else if (typeof args[0] === \"string\" || typeof args[0] === \"number\") {\n    id = args[0]\n  } else {\n    initializer = args[0]\n    id = args[1]\n  }\n\n  const store = useContext(StateInspectorContext)\n\n  const initializedState = initializer\n    ? initializer(initialState)\n    : initialState\n\n  return store && id\n    ? useHookedReducer(reducer, initializedState, store, id)\n    : initializer\n    ? useReactReducer(reducer, initialState, initializer)\n    : useReactReducer(reducer, initialState)\n}\n","/* eslint-disable react-hooks/rules-of-hooks */\nimport { useHookedReducer } from \"./useReducer\"\nimport { useMemo, useContext, useState as useReactState } from \"react\"\nimport { EnhancedStore, ReducerOptions, StateInspectorContext } from \"./context\"\n\ntype StateAction<S> = S | ((s: S) => S)\n\nfunction stateReducer<S>(state: S, action: StateAction<S>): S {\n  return typeof action === \"function\" ? (action as (s: S) => S)(state) : action\n}\n\nexport const useState = <S>(\n  initialState: S | (() => S),\n  id: string | number,\n  options: ReducerOptions = {}\n) => {\n  const inspectorStore = useContext(StateInspectorContext)\n  // Keeping the first values\n  const [store, reducerId] = useMemo<\n    [EnhancedStore | undefined, string | number]\n  >(() => [inspectorStore, id], [])\n\n  if (!store || !reducerId) {\n    return useReactState<S>(initialState)\n  }\n\n  const finalInitialState = useMemo<S>(\n    () =>\n      typeof initialState === \"function\"\n        ? (initialState as () => S)()\n        : initialState,\n    []\n  )\n\n  return useHookedReducer<S, any>(\n    stateReducer,\n    finalInitialState,\n    store,\n    reducerId,\n    options\n  )\n}\n"],"names":["store","StateInspectorContext","React","createContext","undefined","registered","useHookedReducer","reducer","initialState","reducerId","options","initialReducerState","useState","initialStateInStore","getState","localState","setState","dispatch","action","type","payload","cleanup","teardown","registerHookedReducer","lastReducerState","unsubscribe","subscribe","reducerState","useEffect","stateReducer","state","children","props","name","actionsDenylist","window","__REDUX_DEVTOOLS_EXTENSION__","registeredReducers","createStore","obj","keyToRemove","actionReducerId","split","isInitAction","test","currentState","Object","keys","filter","key","reduce","acc","concat","teardownOnUnmount","createReinspectStore","Provider","value","id","initializer","useContext","initializedState","useReactReducer","inspectorStore","useMemo","useReactState"],"mappings":"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"}